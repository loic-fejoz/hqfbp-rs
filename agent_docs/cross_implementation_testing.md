# Cross-Implementation Testing

To ensure seamless interoperability between the Rust implementation (`hqfbp-rs`) and the Python reference implementation (`py-hqfbp`), we use a suite of standardized samples and automated benchmark scripts.

## Python Samples

Standardized KISS samples are generated by the Python implementation to cover various protocol features. These samples are stored in the `../py-hqfbp/samples/` directory.

### Generating Samples
In the `py-hqfbp` repository:
```bash
python3 scripts/generate_samples.py
```

### Standard Sample Suite
| Test Case | Encodings | Description |
| :--- | :--- | :--- |
| `basic` | `h,crc32` | Standard header and CRC. |
| `compressed` | `gzip,h,crc32` | Stream compression (gzip). |
| `fec_rs`| `h,rs(255,223)` | Reed-Solomon error correction. |
| `fec_rq`| `h,rq(dlen,512,128)` | RaptorQ fountain code with dynamic length. |
| `complex` | `gzip,h,rs(255,223),crc32` | Combined compression, FEC, and CRC. |
| `scrambled` | `scr(0x1234),h,crc32` | Polynomial scrambling. |
| `chunked_large` | `gzip,h,crc32` | Multi-PDU message (fragmentation). |
| `repeat` | `h,repeat(3),crc16` | PDU repetition with CRC16. |

## Automated Benchmarking

We use an automated script to validate that Rust can successfully unpack and reassemble every sample generated by Python.

### Running the Benchmark
In the root of `hqfbp-rs`:
```bash
make test-py-bench
```
This runs `scripts/test_against_py_samples.py`, which compares the output of `unpack` in Rust against the original data and the Python-generated metadata.

### Interpreting Results
- **Unpack Status: OK**: The Rust implementation successfully recovered the original data from the Python KISS sample. This is the primary metric for interoperability.
- **Pack Identity: FAIL (Mismatch)**: This is **expected**. Rust and Python may produce different binary PDUs for the same input due to non-deterministic CBOR key ordering in different libraries (`minicbor` vs `cbor2`). As long as they can *unpack* each other's data, interoperability is achieved.

## Known Interoperability Fixes

During the development of the Rust implementation, several critical bugs were fixed to achieve 100% unpack compatibility:

1.  **Double-Decode Prevention**: Modified `complete_message` in `src/deframer.rs` to prevent re-applying encodings (like `Crc32`) that Phase 1 already handled.
2.  **Implicit Chunking**: Ensured that fragmented stream-compressed messages (without explicit block FEC) are correctly joined before decompression.
3.  **CRC16 Initialization**: Aligned Rust `CRC_16_XMODEM` with Python's `0xFFFF` initialization.
4.  **Late Truncation**: Ensured that `payload_size` truncation happens BEFORE decoding layers that might have appended padding.
